### DONE ### -----------------------------------------------------------------------------------------------------------



### NOW ### ------------------------------------------------------------------------------------------------------------
c writer
    implement writer for c entities
    think of possible tasks to create

    class/object definition
        as a structure with related functions in multiple files
        structure in separate file
        function headers in separate file
        function implementation in separate file

mg to c converter
    convert mg runtime or logical entities to c entities?


### SOON ### -----------------------------------------------------------------------------------------------------------
resolver
    aliases has to be stored somehow, or searched by context

    maybe separate step in resolver to fill in context entities ???
        that would require re-creating context for each entity ...
        better would be temporary context object that would be filled with all possible entity links
        but links can be created not only with name ... operators too, and depends on input parameters too

runtime entities
    function calls will have only variables as parameter
    there will be anonymous variables (for more complicated expressions)

    think of what interpreter will be actually using at runtime
        object definition, function definition, thread, instruction, command

    instruction
        its an elementary command (not necessarily equal to cpu instruction)
        all executable should be just a bunch of instructions with input and output
        dot operator is actually hidden instruction


### LATER ### ----------------------------------------------------------------------------------------------------------
resolver
    support for custom stamps
        needs to resolve them in the first pass
        in second will resolve everything else

mg, interpreter and physical entities
    save physical entities as binary
    our language requirements
            good balance of mixed raw and dynamic behaviour
            while keeping the thing as simple as possible
            primarly would be dynamic and for special cases raw support
            every object sould have its parent
            objects should not be destroyed when there is dynamic reference to them (there can stil be a raw one though)
                instead they should be either moved to trash or an error should be thrown

            how to acomplish mixed raw and dynamic:
                for special cases, use @raw stamp for variable (or even a class? in case of c structures)
                or add special sign to the variable, like $
                also, for raws need to specify if padded or packed

        there could be more types of variables
            raw - just holding reference to the object
            extended - holding reference to the object + to its parent or type

        each object should have its parent who is responsible for freeing them when needed
            moving to trash that will take care of them
            should be able to check if can or cannot free it (needs counter for each object)
            an idea: moving objets to trash and checking out this trach with a command to free memory
                     only free when there is no more references to that object

test
    types.mg - define all required operators in test file

language
    add option to specify target mg language version
        file based
        project based

    templates !!! or collections ... !
    exceptions - type for buildin, SAVEPOINT/TRY, CATCH, ROLLBACK, ...

    compilation
        build stamp definitions

    aggregation as clever pointers
        option to track normal pointers too in debug mode

    automatické volání konstruktorů destruktorů ???
        kdy a jak?

    modules
    custom stamps definitions
    stamp or keyword for static / nonstatic variable / function?

translator to c/cpp

compiler
    stamp group / types
    add healing spots
        not only separating compilation of each line
        but also a part until which line is correct and after which is errorneous
            process line only up until the point where is correct
            automatically close all brackets and other groups
        do not add more errors if (probably current task?) already has some
            because the new ones are most probably caused by the previous ones


### IDEAS ### ----------------------------------------------------------------------------------------------------------
language
    an idea - class could be location at the same time
        this could allow to place "inner" classes and functions in separate files
        on filesystem level, it could be solved as a folder with the same name as the class (without the extension)

distinguish "objrects" and "attribute objects" somehow
different levels of resolution of names - file level resolution, project level resolution
types with & $ ?
hierarchical objects - store reference to parent and update when needed
symbolic links insted of / along with references
    will store absolute or relative path (integers) to given object

explorer - find usages of an entity